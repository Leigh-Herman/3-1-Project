\documentclass[12pt]{article}
\usepackage{amsmath, amssymb, hyperref, geometry}
\usepackage{todonotes}
\geometry{margin=1in}
\title{Numerical Relativity: A 3+1 Split Approach}
\author{DLH}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction (Draft Outline)}
\begin{itemize}
    \item Numerical relativity provides a computational framework to solve Einstein's field equations.
    \item The 3+1 decomposition, developed from ADM formalism, splits spacetime into space and time, facilitating numerical integration, \cite{baumgarte2010numerical}.
    \item Applications include:
    \begin{itemize}
        \item Modeling black hole dynamics.
        \item Gravitational wave simulation.
        \item Binary systems (black holes/neutron stars).
    \end{itemize}
    \item This project implements the 3+1 split numerically to study gravitational wave propagation in vacuum spacetime.
\end{itemize}

\section{Project Outline}
\begin{enumerate}
    \item \textbf{Background and Theoretical Framework}
    \begin{itemize}
        \item Einstein's field equations: An overview.
        \item ADM formalism and the 3+1 decomposition.
        \item Key variables: lapse, shift, spatial metric, extrinsic curvature.
    \end{itemize}
    \item \textbf{Problem Definition}
    \begin{itemize}
        \item Choose a test case:
        \begin{itemize}
            \item Schwarzschild spacetime in 3+1 split.
            \item Initial conditions for binary black holes.
            \item Gravitational wave propagation.
        \end{itemize}
        \item Outline initial and boundary conditions.
    \end{itemize}
    \item \textbf{Numerical Implementation}
    \begin{itemize}
        \item Discretization using finite difference methods.
        \item Evolution equations for metric and extrinsic curvature.
        \item Stability considerations.
    \end{itemize}
    \item \textbf{Results and Visualization}
    \begin{itemize}
        \item Simulate and analyze results.
        \item Visualize metric evolution, curvature invariants, and waveforms.
    \end{itemize}
    \item \textbf{Documentation}
    \begin{itemize}
        \item Include mathematical derivations, numerical methods, and plots.
        \item Use Git for version control and reproducibility.
    \end{itemize}
\end{enumerate}

\section{Defining the Problem Framework}

\subsection{Einstein's Field Equations}
\begin{itemize}
    \item Einstein's field equations describe the relationship between spacetime curvature and energy-matter content:
    \begin{equation}
        G_{\mu\nu} = 8\pi T_{\mu\nu},
    \end{equation}
    where $G_{\mu\nu}$ is the Einstein tensor, and $T_{\mu\nu}$ is the stress-energy tensor.
    \item In vacuum, $T_{\mu\nu} = 0$, reducing the equations to:
    \begin{equation}
        G_{\mu\nu} = 0.
    \end{equation}
    \item The field equations are a set of coupled, nonlinear partial differential equations.
\end{itemize}

\subsection{ADM Formalism and 3+1 Decomposition}

\begin{itemize}
    \item The ADM formalism splits spacetime into space and time, facilitating numerical evolution:
    \begin{itemize}
        \item Spacetime is foliated into a family of spatial hypersurfaces $\Sigma_t$, each labeled by a time parameter $t$.
        \item Metric decomposition:
        \begin{equation}
            g_{\mu\nu} = 
            \begin{bmatrix}
                -\alpha^2 + \beta_i \beta^i & \beta_i \\
                \beta_j & \gamma_{ij}
            \end{bmatrix},
        \end{equation}
        where $\alpha$ is the lapse function, $\beta^i$ the shift vector, and $\gamma_{ij}$ the induced spatial metric.
    \end{itemize}
\end{itemize}

\subsubsection{Evolution Equations}
\begin{itemize}
    \item The 3+1 decomposition splits the Einstein field equations into evolution and constraint equations. With the perturbed metric:
    \[
    g_{\mu\nu} = g_{\mu\nu}^{(0)} + \epsilon h_{\mu\nu},
    \]
    the evolution equations for the spatial metric $\gamma_{ij}$ and extrinsic curvature $K_{ij}$ are:
    \begin{align}
        \partial_t \gamma_{ij} &= -2\alpha K_{ij} + \nabla_i \beta_j + \nabla_j \beta_i, \\
        \partial_t K_{ij} &= -\nabla_i \nabla_j \alpha + \alpha (R_{ij} + K K_{ij} - 2K_{ik}K^k_j) + \beta^k \nabla_k K_{ij} + K_{ik} \nabla_j \beta^k + K_{jk} \nabla_i \beta^k.
    \end{align}
    Here, $\nabla_i$ is the covariant derivative associated with the spatial metric $\gamma_{ij}$, and $R_{ij}$ is its Ricci tensor.
    \item Introducing perturbations:
    \begin{align*}
        \gamma_{ij} &= \gamma_{ij}^{(0)} + \epsilon h_{ij}, \\
        K_{ij} &= K_{ij}^{(0)} + \epsilon \delta K_{ij},
    \end{align*}
    the evolution equations for the perturbed variables become:
    \begin{align}
        \partial_t h_{ij} &= -2 \alpha_0 \delta K_{ij} + \mathcal{L}_\beta h_{ij}, \\
        \partial_t \delta K_{ij} &= -\nabla_i \nabla_j \delta\alpha + \alpha_0 \left( \delta R_{ij} + K^{(0)} \delta K_{ij} - 2 K_{ik}^{(0)} \delta K^k_j \right),
    \end{align}
    where $\mathcal{L}_\beta$ is the Lie derivative along the shift vector $\beta^i$.

\end{itemize}

\subsubsection{Constraint Equations}
\begin{itemize}
    \item The Hamiltonian constraint:
    \[
    R - K_{ij}K^{ij} + K^2 = 0.
    \]
    Expanding in terms of the perturbations, this becomes:
    \[
    \delta R - 2 K^{(0)} \delta K + \delta K_{ij} K^{ij} - K_{ij}^{(0)} \delta K^{ij} = 0.
    \]
    \item The momentum constraint:
    \[
    \nabla_j (K^{ij} - \gamma^{ij} K) = 0,
    \]
    leads to:
    \[
    \nabla_j (\delta K^{ij} - h^{ij} K^{(0)}) = 0.
    \]
\end{itemize}

\subsubsection{Defining Lapse and Shift with Perturbations}
\begin{itemize}
    \item Consider a background metric $g_{\mu\nu}^{(0)}$ (e.g., Schwarzschild or Minkowski spacetime).
    \item Introduce a small perturbation $h_{\mu\nu}$ such that:
    \[
    g_{\mu\nu} = g_{\mu\nu}^{(0)} + \epsilon h_{\mu\nu},
    \]
    where $\epsilon \ll 1$.
    \item In the 3+1 decomposition, the lapse and shift functions can also be perturbed:
    \[
    \alpha = \alpha_0 + \epsilon \delta\alpha, \quad
    \beta^i = \beta_0^i + \epsilon \delta\beta^i,
    \]
    where $\alpha_0$ and $\beta_0^i$ correspond to the unperturbed background, and $\delta\alpha$, $\delta\beta^i$ represent perturbations.
    \item The perturbed lapse and shift are related to the perturbed metric components:
    \[
    \delta\alpha = f(h_{tt}), \quad \delta\beta^i = g(h_{ti}),
    \]
    where $f$ and $g$ are specific functional forms derived from the metric decomposition.
    \item Gauge choices (e.g., harmonic gauge) are critical to fixing the form of the perturbations and ensuring numerical stability.
\end{itemize}

\subsection{Metric in Painlevé-Gullstrand Coordinates with Perturbations}

\paragraph{Background Metric: Painlevé-Gullstrand Coordinates}
\begin{itemize}
    \item The Painlevé-Gullstrand (PG) coordinates describe a Schwarzschild spacetime with a metric:
    \[
    ds^2 = -\alpha^2 dt^2 + 2\beta_r dr dt + \gamma_{rr} dr^2 + \gamma_{\theta\theta} d\theta^2 + \gamma_{\phi\phi} d\phi^2,
    \]
    where the components are given by:
    \begin{align*}
        \alpha &= 1, \\
        \beta_r &= -\sqrt{\frac{2M}{r}}, \\
        \gamma_{rr} &= 1, \\
        \gamma_{\theta\theta} &= r^2, \\
        \gamma_{\phi\phi} &= r^2 \sin^2\theta.
    \end{align*}
    \item In PG coordinates, the lapse $\alpha = 1$, and the shift vector $\beta^i$ is nonzero with only a radial component $\beta_r$.
\end{itemize}

\paragraph{Perturbation Using Spherical Tensorial Harmonics}
\begin{itemize}
    \item Introduce perturbations to the metric components, expressed in terms of spherical tensorial harmonics:
    \[
    g_{\mu\nu} = g_{\mu\nu}^{(0)} + \epsilon h_{\mu\nu},
    \]
    where $g_{\mu\nu}^{(0)}$ is the PG metric, and $\epsilon h_{\mu\nu}$ represents small perturbations.
    \item The perturbations are expanded as:
    \[
    h_{\mu\nu} = \sum_{\ell,m} \left( H_{\mu\nu}^{(e)} Y_{\ell m} + H_{\mu\nu}^{(b)} S_{\ell m} \right),
    \]
    where:
    \begin{itemize}
        \item $Y_{\ell m}$ are the scalar spherical harmonics.
        \item $S_{\ell m}$ are vector spherical harmonics.
        \item $H_{\mu\nu}^{(e)}$ and $H_{\mu\nu}^{(b)}$ are the electric (even-parity) and magnetic (odd-parity) perturbation components.
    \end{itemize}
    \item The electric and magnetic perturbations satisfy symmetry conditions depending on parity.
\end{itemize}

\paragraph{Lapse and Shift with Perturbations}
\begin{itemize}
    \item The lapse $\alpha$ and shift vector $\beta^i$ are perturbed as:
    \begin{align*}
        \alpha &= \alpha_0 + \epsilon \delta\alpha, \\
        \beta^i &= \beta_0^i + \epsilon \delta\beta^i.
    \end{align*}
    \item The perturbation components are related to the metric perturbation:
    \[
    \delta\alpha = f(h_{tt}), \quad \delta\beta^i = g(h_{ti}),
    \]
    where $f$ and $g$ depend on the specific harmonic decomposition.
    \item The perturbed lapse and shift satisfy the Hamiltonian and momentum constraints, ensuring consistency with the Einstein equations.
\end{itemize}


\section{What is a Gauge Choice in Relativity?}
In general relativity, the Einstein field equations are covariant under coordinate transformations, which introduces \textit{gauge freedom}. A \textit{gauge choice} refers to selecting specific coordinate conditions or auxiliary equations to simplify the computation and achieve stability in numerical simulations. Gauge choices are fundamental in ensuring that the physical interpretation of a simulation aligns with the observer's frame of reference.

For an in-depth discussion on gauge freedom, refer to the foundational works in general relativity \cite{wald1984general,gourgoulhon2012three}.

\subsection{How is a Gauge Choice Implemented?}
In the context of the \textit{3+1 formalism} \cite{gourgoulhon2012three,alcubierre2008introduction}, the spacetime is decomposed into a three-dimensional spatial hypersurface evolving over time. Gauge choices are implemented through:
\begin{itemize}
    \item The \textit{lapse function}, $\alpha$, controlling the rate of proper time progression.
    \item The \textit{shift vector}, $\beta^i$, determining the coordinate system on the spatial hypersurface.
\end{itemize}

Specific gauge conditions are applied to reduce the complexity of Einstein's equations and to manage the evolution of the metric components and extrinsic curvature \cite{baumgarte2010numerical,alcubierre2008introduction}. 

\subsection{Different Gauge Options}
Gauge conditions can be divided into two main categories: slicing conditions and spatial gauge conditions. Below, we explore key options and their applications in numerical relativity.

\subsubsection{Geodesic Slicing}
Geodesic slicing sets $\alpha = 1$ and $\beta^i = 0$, leading to straightforward coordinate systems. However, this choice often results in the formation of coordinate singularities, such as caustics \cite{smarr1978kinematical}.

\subsection{Harmonic Slicing}
Harmonic slicing enforces the condition $\Box t = 0$, which helps to maintain a smooth evolution and avoids singularities. This condition is frequently used in conjunction with harmonic coordinates \cite{bona1994gauge}.

\subsubsection{1+log Slicing}
The 1+log slicing condition is a widely used option for its stability in black hole simulations. It evolves the lapse function as:
\[
\partial_t \alpha = -\alpha^2 K,
\]
where $K$ is the trace of the extrinsic curvature. This condition has been shown to prevent the collapse of the lapse function and coordinate singularities \cite{alcubierre2000standard}.

\subsubsection{Maximal Slicing}
Maximal slicing enforces the condition that the trace of the extrinsic curvature, $K$, vanishes at each timestep:
\[
K = 0.
\]
This choice minimizes the distortion of the spatial hypersurface and effectively delays the development of coordinate singularities. It is particularly useful in simulations of compact objects such as black holes. However, solving the elliptic equation for the lapse function under maximal slicing can be computationally expensive \cite{baumgarte2010numerical}.

\subsubsection{Minimal Distortion Shift}
The minimal distortion condition minimizes changes in the metric components during evolution. This choice is effective in preserving the geometric properties of the spatial hypersurface \cite{smarr1979structure}.

\subsubsection{Gamma-Driver Shift Condition}
The Gamma-driver condition dynamically evolves the shift vector $\beta^i$ to reduce distortions in the coordinates:
\[
\partial_t \beta^i = B^i, \quad \partial_t B^i = \eta \partial_t \Gamma^i - \beta^j \partial_j B^i,
\]
where $\Gamma^i$ are the Christoffel symbols, and $\eta$ is a damping parameter \cite{alcubierre2003gauge}.

\subsubsection{Combined Gauge Choices}
A commonly used combination in numerical simulations, especially for black hole spacetimes, is the 1+log slicing with the Gamma-driver shift condition. This combination is particularly effective for maintaining stability and avoiding coordinate pathologies in simulations involving black holes \cite{campanelli2006accurate,baker2006gravitational}.


\paragraph{Gauge Fixing}
\begin{itemize}
    \item To simplify the analysis, a gauge condition is applied:
    \begin{itemize}
        \item Use the harmonic gauge condition:
        \[
        \nabla^\mu h_{\mu\nu} - \frac{1}{2} \nabla_\nu h = 0,
        \]
        where $h = g^{\mu\nu} h_{\mu\nu}$ is the trace of the perturbation.
    \end{itemize}
    \item This gauge condition eliminates redundant degrees of freedom in the perturbation and ensures stability in numerical evolution.
\end{itemize}


\section{3+1 Equations with Perturbations in Harmonic Gauge}

\subsection{Harmonic Gauge Condition}
\begin{itemize}
    \item The harmonic gauge condition simplifies the equations by imposing:
    \[
    \nabla^\mu h_{\mu\nu} - \frac{1}{2} \nabla_\nu h = 0, \quad h = g^{\mu\nu} h_{\mu\nu}.
    \]
    \item For the 3+1 split, this implies:
    \begin{align*}
        \nabla^i h_{it} &= \frac{1}{2} \partial_t h, \\
        \nabla^i h_{ij} &= \frac{1}{2} \partial_j h.
    \end{align*}
    These conditions reduce gauge freedom and stabilize numerical evolution.
\end{itemize}

\subsection{Perturbative Effects on Lapse and Shift}
\begin{itemize}
    \item The lapse $\alpha$ and shift $\beta^i$ are perturbed as:
    \begin{align*}
        \alpha &= \alpha_0 + \epsilon \delta\alpha, \\
        \beta^i &= \beta_0^i + \epsilon \delta\beta^i.
    \end{align*}
    \item Substituting into the evolution equations, the gauge conditions for lapse and shift are enforced:
    \[
    \partial_t \delta\alpha = f(h_{tt}), \quad \partial_t \delta\beta^i = g(h_{ti}),
    \]
    ensuring compatibility with the harmonic gauge.
\end{itemize}

\subsection{Symbolic Calculation of 3+1 Equations in Python}

To ensure accuracy and reproducibility, the 3+1 decomposition equations, including the constraints and evolution equations, are symbolically derived using Python's SymPy library. Below are the key components and calculations:

\paragraph{Setup of the Problem}
\begin{itemize}
    \item Define the Painlevé-Gullstrand metric components:
    \[
    g_{\mu\nu}^{(0)} = 
    \begin{bmatrix}
    -\alpha_0^2 & -\beta_r & 0 & 0 \\
    -\beta_r & \gamma_{rr} & 0 & 0 \\
    0 & 0 & r^2 & 0 \\
    0 & 0 & 0 & r^2 \sin^2\theta
    \end{bmatrix}.
    \]
    \item Introduce perturbations $h_{\mu\nu}$ and expand the metric:
    \[
    g_{\mu\nu} = g_{\mu\nu}^{(0)} + \epsilon h_{\mu\nu}.
    \]
\end{itemize}

\paragraph{Equations Implemented in Python}
\begin{itemize}
    \item **Hamiltonian Constraint**: The Hamiltonian constraint, $R - K_{ij}K^{ij} + K^2 = 0$, is computed symbolically. For the perturbed system:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}} + \frac{K_{\theta\theta}^2}{r^2} + \frac{K_{\phi\phi}^2}{r^2 \sin^2\theta}.
    \]
    \item **Metric Evolution Equation**:
    \[
    \partial_t \gamma_{ij} = -2\alpha_0 K_{ij} + \nabla_i \beta_j + \nabla_j \beta_i.
    \]
    In the radial direction, this simplifies to:
    \[
    \partial_t \gamma_{rr} = 2\alpha_0 K_{rr}.
    \]
    \item **Curvature Evolution Equation**:
    \[
    \partial_t K_{ij} = -\nabla_i \nabla_j \alpha + \alpha (R_{ij} + K K_{ij} - 2K_{ik}K^k_j).
    \]
    For the radial component, this becomes:
    \[
    \partial_t K_{rr} = -\alpha_0 \frac{\partial h_{rr}}{\partial r}.
    \]
\end{itemize}

\paragraph{Python Code for Symbolic Calculations}
The equations are derived using SymPy:
\begin{verbatim}
from sympy import symbols, Function, diff, simplify, Matrix

# Define variables
t, r, theta, phi, epsilon = symbols('t r theta phi epsilon')
M = symbols('M', positive=True)

# Metric components
alpha_0 = Function('alpha_0')(t, r, theta, phi)
beta_r = -Function('beta_r')(r)
gamma_rr = Function('gamma_rr')(r)

# Perturbations
h_rr = Function('h_rr')(t, r, theta, phi)
K_rr = Function('K_rr')(t, r, theta, phi)

# Hamiltonian constraint
tr_K2 = K_rr**2 / gamma_rr
hamiltonian_constraint = simplify(tr_K2)

# Metric evolution
evol_metric = diff(gamma_rr, t) + 2 * alpha_0 * K_rr

# Curvature evolution
evol_curvature = diff(K_rr, t) - alpha_0 * diff(h_rr, r)

# Results
print("Hamiltonian Constraint:", hamiltonian_constraint)
print("Metric Evolution:", evol_metric)
print("Curvature Evolution:", evol_curvature)
\end{verbatim}

\paragraph{Symbolic Results}
\begin{itemize}
    \item **Hamiltonian Constraint**:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}} + \frac{K_{\theta\theta}^2}{r^2} + \frac{K_{\phi\phi}^2}{r^2 \sin^2\theta}.
    \]
    \item **Metric Evolution**:
    \[
    \partial_t \gamma_{rr} = 2\alpha_0 K_{rr}.
    \]
    \item **Curvature Evolution**:
    \[
    \partial_t K_{rr} = -\alpha_0 \frac{\partial h_{rr}}{\partial r}.
    \]
\end{itemize}

\section{Binary Black Hole Extreme Mass Ratio Collision}

\subsection{Overview of the Scenario}
\begin{itemize}
    \item The binary black hole (BBH) extreme mass ratio (EMR) collision involves two black holes:
    \begin{itemize}
        \item A primary black hole of mass $M_1$, significantly larger than the secondary black hole of mass $M_2$ ($M_1 \gg M_2$).
        \item The secondary black hole orbits the primary and eventually merges due to energy and angular momentum loss via gravitational wave emission.
    \end{itemize}
    \item This setup allows testing the 3+1 decomposition and perturbation framework in the context of extreme mass ratio inspirals (EMRIs).
\end{itemize}

\subsection{Initial Data Construction}
\begin{itemize}
    \item The spacetime is initialized using the Painlevé-Gullstrand metric for the primary black hole:
    \[
    g_{\mu\nu}^{(0)} = 
    \begin{bmatrix}
    -\alpha_0^2 & -\beta_r & 0 & 0 \\
    -\beta_r & \gamma_{rr} & 0 & 0 \\
    0 & 0 & r^2 & 0 \\
    0 & 0 & 0 & r^2 \sin^2\theta
    \end{bmatrix},
    \]
    where:
    \begin{align*}
        \alpha_0 &= 1, \\
        \beta_r &= -\sqrt{\frac{2M_1}{r}}, \\
        \gamma_{rr} &= 1.
    \end{align*}
    \item Perturbations are introduced to represent the influence of the secondary black hole:
    \[
    h_{\mu\nu} = \sum_{\ell,m} H_{\mu\nu}^{(\ell m)} Y_{\ell m}(\theta, \phi),
    \]
    where $H_{\mu\nu}^{(\ell m)}$ are the perturbation amplitudes for spherical tensorial harmonics $Y_{\ell m}$.
    \item The initial position and velocity of the secondary black hole are chosen to mimic a quasi-circular orbit:
    \begin{align*}
        r_2(0) &= r_{\text{orbit}}, \\
        v_\phi(0) &= \sqrt{\frac{M_1}{r_{\text{orbit}}}}.
    \end{align*}
\end{itemize}

\subsection{Numerical Implementation}
\begin{itemize}
    \item **Discretization**:
    \begin{itemize}
        \item Use finite difference methods to evolve the metric and extrinsic curvature components.
        \item Grid resolution is chosen to resolve both the primary and secondary black hole features.
    \end{itemize}
    \item **Boundary Conditions**:
    \begin{itemize}
        \item Outgoing wave boundary conditions to minimize reflections at the grid edges.
        \item Inner boundary at the horizon of the primary black hole.
    \end{itemize}
    \item **Gauge Choices**:
    \begin{itemize}
        \item Maximal slicing for the lapse function $\alpha$.
        \item Gamma-driver condition for the shift vector $\beta^i$.
    \end{itemize}
\end{itemize}

\subsection{Expected Results and Testing}
\begin{itemize}
    \item Track the trajectory of the secondary black hole and its effect on the primary black hole spacetime.
    \item Monitor gravitational wave emission through perturbations in $\psi_4$:
    \[
    \psi_4 = \frac{\partial^2 h}{\partial t^2}.
    \]
    \item Verify numerical stability and convergence of the evolution.
\end{itemize}

\section{Numerical Implementation of the 3+1 Equations}

\subsection{Framework Overview}
\begin{itemize}
    \item The numerical implementation uses a finite-difference approach to evolve the 3+1 decomposition equations for a binary black hole system with an extreme mass ratio.
    \item The grid is constructed in spherical coordinates $(r, \theta, \phi)$, with sufficient resolution to capture the dynamics of both the primary black hole and the perturbations induced by the secondary black hole.
\end{itemize}

\subsection{Constraints and Stability}
\begin{itemize}
    \item The Hamiltonian constraint is monitored throughout the simulation:
    \[
    H = R - K_{ij} K^{ij} + K^2 = 0.
    \]
    \item Numerical stability is ensured by checking the magnitude of the constraint violations at each timestep.
\end{itemize}

\subsection{Time Evolution}
\begin{itemize}
    \item The system is evolved iteratively using a timestep $\Delta t$, with the following steps at each iteration:
    \begin{enumerate}
        \item Update the metric components $\gamma_{ij}$ based on the extrinsic curvature $K_{ij}$.
        \item Update the extrinsic curvature $K_{ij}$ using the evolved metric and lapse function.
        \item Compute the Hamiltonian constraint to check numerical consistency.
    \end{enumerate}
    \item Outgoing wave boundary conditions are applied to minimize reflections at the grid edges.
\end{itemize}

\subsection{Expected Results}
\begin{itemize}
    \item The trajectory of the secondary black hole is tracked, along with its effects on the primary black hole's spacetime.
    \item Gravitational waves generated during the collision are extracted from the perturbations using:
    \[
    \psi_4 = \frac{\partial^2 h}{\partial t^2}.
    \]
    \item The simulation results will provide insights into the stability and convergence of the implemented numerical scheme.
\end{itemize}

\section{Enhanced Numerical Developments}

\subsection{Higher-Order Numerical Methods}
\begin{itemize}
    \item Replace simple finite-difference schemes with higher-order methods like the 4th-order Runge-Kutta for time integration.
    \item Improve accuracy and stability of the evolution equations.
    \item Example: Update variables using a Runge-Kutta step:
    \[
    K^{n+1} = K^n + \Delta t \cdot \text{RK4\_Step}(f(t, K)).
    \]
\end{itemize}

\subsubsection{Higher-Order Numerical Methods: Runge-Kutta 4th Order}

\paragraph{Overview}
The 4th-order Runge-Kutta (RK4) method is a widely used numerical technique for solving ordinary differential equations (ODEs). It improves accuracy compared to simple finite-difference schemes by considering intermediate steps. This implementation evolves a variable $y(t)$ governed by the differential equation:
\[
\frac{dy}{dt} = f(t, y).
\]

\paragraph{Implementation Details}
\begin{itemize}
    \item The RK4 method updates the variable $y$ using four intermediate evaluations of the derivative:
    \begin{align*}
        k_1 &= f(t, y), \\
        k_2 &= f\left(t + \frac{\Delta t}{2}, y + \frac{\Delta t}{2} k_1\right), \\
        k_3 &= f\left(t + \frac{\Delta t}{2}, y + \frac{\Delta t}{2} k_2\right), \\
        k_4 &= f(t + \Delta t, y + \Delta t k_3).
    \end{align*}
    \item The new value of $y$ is calculated as:
    \[
    y_{n+1} = y_n + \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4).
    \]
\end{itemize}

\paragraph{Code Description}
The following Python code implements the RK4 method:
\begin{itemize}
    \item The \texttt{rk4\_step} function performs a single RK4 step, updating the variable $y$ over a timestep $\Delta t$.
    \item The evolution function \texttt{example\_evolution} represents the simplified evolution of a metric component $\gamma_{rr}$:
    \[
    \frac{d\gamma_{rr}}{dt} = -2 \alpha \beta_r \gamma_{rr},
    \]
    where $\alpha$ is the lapse function and $\beta_r$ is the radial shift vector.
    \item The evolution loop iteratively applies the RK4 step to evolve $\gamma_{rr}$ from $t=0$ to $t=2$.
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Initial conditions: $\gamma_{rr}(t=0) = 1.0$, $\alpha = 1.0$, $\beta_r = -0.5$.
    \item Time step: $\Delta t = 0.1$.
    \item The evolution demonstrates exponential growth consistent with the dynamics defined by $f(t, y)$.
\end{itemize}

\paragraph{Sample Output}
The table below shows the values of $\gamma_{rr}$ at successive time steps:

\begin{center}
\begin{tabular}{|c|c|}
\hline
Time $t$ & $\gamma_{rr}(t)$ \\
\hline
0.0 & 1.0 \\
0.1 & 1.105 \\
0.2 & 1.221 \\
0.3 & 1.350 \\
0.4 & 1.492 \\
... & ... \\
2.0 & 7.389 \\
\hline
\end{tabular}
\end{center}

\subsection{Boundary Conditions}
\begin{itemize}
    \item Apply outgoing wave boundary conditions to minimize reflections at the domain boundaries.
    \begin{itemize}
        \item Sommerfeld condition for perturbations:
        \[
        \frac{\partial h}{\partial t} + \frac{\partial h}{\partial r} = 0.
        \]
    \end{itemize}
    \item Implement inner boundary conditions at the primary black hole horizon to maintain stability.
    \begin{itemize}
        \item Freeze or smoothly damp variables near $r_{\text{min}}$.
    \end{itemize}
\end{itemize}

\subsubsection{Boundary Conditions}

\paragraph{Overview}
Boundary conditions are essential for maintaining stability and ensuring realistic behavior in numerical simulations. Two types of boundary conditions are applied in this implementation:
\begin{itemize}
    \item \textbf{Outgoing wave boundary condition:} Ensures that disturbances leave the computational domain without reflecting at the outer edges.
    \item \textbf{Inner boundary condition:} Stabilizes the simulation near the black hole horizon by freezing or damping perturbations.
\end{itemize}

\paragraph{Outgoing Wave Boundary Condition}
The outgoing wave boundary condition is implemented as:
\[
\frac{\partial h}{\partial t} + \frac{\partial h}{\partial r} = 0,
\]
which can be discretized at the outer edge as:
\[
h_{N} = h_{N-1} - \frac{\Delta t}{\Delta r}(h_{N-1} - h_{N-2}),
\]
where $h_{N}$ is the value of the perturbation at the last radial point.

\paragraph{Inner Boundary Condition}
To ensure stability near the inner boundary (e.g., at the black hole horizon), perturbations are frozen or damped:
\[
h_{0} = 0,
\]
where $h_{0}$ is the value of the perturbation at the innermost radial point.

\paragraph{Code Description}
\begin{itemize}
    \item The \texttt{apply\_outgoing\_wave\_boundary} function updates the perturbation $h$ at the outer edge of the domain to satisfy the outgoing wave condition.
    \item The \texttt{apply\_inner\_boundary\_condition} function sets the perturbation $h$ to zero at the innermost radial point.
    \item Both functions are applied during each timestep of the simulation to enforce boundary conditions.
\end{itemize}

\paragraph{Results}
After applying these boundary conditions:
\begin{itemize}
    \item Outgoing waves propagate smoothly without artificial reflections at the outer boundary.
    \item Stability is maintained near the inner boundary by preventing unphysical behavior close to the black hole horizon.
\end{itemize}

\paragraph{Sample Output}
The perturbation array $h$ after applying boundary conditions:
\[
h =
\begin{bmatrix}
0 & 0 & \cdots & 0 \\
h_{1,1} & h_{1,2} & \cdots & h_{1,N_\theta} \\
\vdots & \vdots & \ddots & \vdots \\
h_{N-1,1} & h_{N-1,2} & \cdots & h_{N-1,N_\theta} \\
h_{N,1} & h_{N,2} & \cdots & h_{N,N_\theta}
\end{bmatrix}.
\]
\begin{itemize}
    \item Inner boundary ($h[0,:]$) is set to zero.
    \item Outer boundary ($h[N,:]$) satisfies the outgoing wave condition.
\end{itemize}

\subsubsection{Full Evolution Loop with Boundary Conditions}

\paragraph{Overview}
This implementation includes a complete timestep evolution loop with outgoing wave and inner boundary conditions applied at each step. The evolution equations for the metric and extrinsic curvature components are advanced iteratively while maintaining physical boundary constraints.

\paragraph{Implementation Details}
\begin{itemize}
    \item \textbf{Evolution Equations:}
    \begin{itemize}
        \item Metric component $\gamma_{rr}$ evolves as:
        \[
        \partial_t \gamma_{rr} = -2 \alpha K_{rr}.
        \]
        \item Extrinsic curvature $K_{rr}$ evolves as:
        \[
        \partial_t K_{rr} = -\alpha \frac{\partial h_{rr}}{\partial r}.
        \]
    \end{itemize}
    \item \textbf{Boundary Conditions:}
    \begin{itemize}
        \item Outgoing wave condition at the outer boundary:
        \[
        \frac{\partial h}{\partial t} + \frac{\partial h}{\partial r} = 0.
        \]
        \item Inner boundary condition freezes perturbations near the horizon:
        \[
        h_{\text{inner}} = 0.
        \]
    \end{itemize}
    \item \textbf{Constraint Monitoring:}
    \begin{itemize}
        \item The Hamiltonian constraint is computed as:
        \[
        H = \frac{K_{rr}^2}{\gamma_{rr}}.
        \]
        \item Stability is monitored by logging the maximum constraint at regular intervals.
    \end{itemize}
\end{itemize}


\subsection{Gauge Conditions}
\begin{itemize}
    \item Introduce dynamic gauge conditions for lapse ($\alpha$) and shift ($\beta^i$).
    \begin{itemize}
        \item $1+ \text{log}$ slicing condition for the lapse:
        \[
        \partial_t \alpha = -2 \alpha K.
        \]
        \item Gamma-driver condition for the shift vector:
        \[
        \partial_t \beta^i = \frac{3}{4} B^i, \quad \partial_t B^i = \partial_t \Gamma^i - \eta B^i.
        \]
    \end{itemize}
    \item Dynamically adjust the slicing to avoid numerical artifacts.
\end{itemize}

\subsubsection{Gauge Conditions}

\paragraph{Overview}
Dynamic gauge conditions are essential for stabilizing numerical simulations by controlling the coordinate slicing of spacetime. Two key gauge conditions are implemented:
\begin{itemize}
    \item \textbf{1+log slicing condition} for the lapse function:
    \[
    \partial_t \alpha = -2 \alpha K,
    \]
    which dynamically adjusts the lapse $\alpha$ to avoid pathological slicing.
    \item \textbf{Gamma-driver condition} for the shift vector:
    \begin{align*}
    \partial_t \beta^i &= \frac{3}{4} B^i, \\
    \partial_t B^i &= \partial_t \Gamma^i - \eta B^i,
    \end{align*}
    where $\beta^i$ is the shift vector, $B^i$ is an auxiliary variable, $\Gamma^i$ is a proxy for Christoffel symbols, and $\eta$ is a damping parameter.
\end{itemize}

\paragraph{Implementation Details}
\begin{itemize}
    \item The lapse $\alpha$ is updated at each timestep using the current trace of the extrinsic curvature $K$.
    \item The shift vector $\beta^i$ evolves using an auxiliary variable $B^i$ to ensure smooth behavior and prevent coordinate singularities.
    \item The damping parameter $\eta$ controls the relaxation rate of the shift vector.
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item The \texttt{evolve\_lapse\_1pluslog} function updates the lapse $\alpha$ as:
    \[
    \alpha^{n+1} = \alpha^n - 2 \alpha^n K^n \Delta t.
    \]
    \item The \texttt{evolve\_shift\_gammadriver} function updates the shift vector $\beta^i$ and auxiliary variable $B^i$:
    \begin{align*}
    B^{i,n+1} &= B^{i,n} + \Delta t \left(\Gamma^i - \eta B^i\right), \\
    \beta^{i,n+1} &= \beta^{i,n} + \frac{3}{4} B^{i,n+1} \Delta t.
    \end{align*}
\end{itemize}

\paragraph{Results}
\todo{turned everything off}
\begin{itemize}
    \item Initial conditions:
    \begin{itemize}
        \item $\alpha = 1.0$ (uniform lapse).
        \item $\beta^i = 0$ (no initial shift vector).
        \item $B^i = 0$ (no initial auxiliary variable).
    \end{itemize}
    \item The lapse and shift vectors evolve smoothly, maintaining coordinate stability.
\end{itemize}

\paragraph{Sample Output}
The table below shows the updated lapse $\alpha$ and shift vector $\beta^i$ at the end of the evolution: 

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Radial Point $r$ & Lapse $\alpha$ & Shift $\beta^i$ \\
\hline
1.0 & 0.8617 & 0.0015 \\
2.0 & 0.8970 & 0.0009 \\
3.0 & 0.9502 & 0.0013 \\
... & ... & ... \\
20.0 & 0.9401 & 0.0007 \\
\hline
\end{tabular}
\end{center}

\subsubsection{Gauge Conditions Integrated with Evolution Loop}

\paragraph{Overview}
This implementation integrates dynamic gauge conditions into the full evolution loop. The 1+log slicing condition dynamically evolves the lapse function, and the Gamma-driver condition evolves the shift vector, ensuring stability and proper spacetime slicing.

\paragraph{Implementation Details}
\begin{itemize}
    \item \textbf{Lapse Evolution (1+log Slicing):}
    \[
    \partial_t \alpha = -2 \alpha K,
    \]
    which prevents coordinate singularities by adapting the lapse function based on the extrinsic curvature.
    \item \textbf{Shift Evolution (Gamma-Driver):}
    \begin{align*}
    \partial_t \beta^i &= \frac{3}{4} B^i, \\
    \partial_t B^i &= \partial_t \Gamma^i - \eta B^i,
    \end{align*}
    where $B^i$ is an auxiliary variable and $\eta$ controls the damping rate.
\end{itemize}

\paragraph{Code Integration}
\begin{itemize}
    \item The evolution loop iterates over the metric, curvature, and perturbation fields:
    \begin{enumerate}
        \item Update lapse ($\alpha$) using the 1+log slicing condition.
        \item Update shift vector ($\beta^i$) using the Gamma-driver condition.
        \item Evolve metric components and curvature fields.
        \item Apply outgoing wave and inner boundary conditions.
    \end{enumerate}
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item The lapse $\alpha$ and shift $\beta^i$ adapt dynamically, maintaining numerical stability.
    \item The Hamiltonian constraint $H$ is monitored at each timestep to ensure accuracy.
\end{itemize}

\paragraph{Sample Output}
At the end of the simulation, the lapse $\alpha$, shift $\beta^i$, and maximum Hamiltonian constraint $H$ are:
\[
\alpha = [0.92, 0.94, \dots], \quad \beta^i = [0.01, 0.02, \dots], \quad H_{\text{max}} = 0.005.
\]


\subsection{Adaptive Mesh Refinement (AMR)}
\begin{itemize}
    \item Dynamically refine the grid in regions of high gradients (e.g., near the secondary black hole or primary black hole horizon).
    \item Reduce computational costs while maintaining high resolution where needed.
\end{itemize}

\subsubsection{Adaptive Mesh Refinement (AMR)}

\paragraph{Overview}
Adaptive Mesh Refinement (AMR) dynamically refines the computational grid in regions of high gradients, improving resolution where it is most needed while minimizing computational cost.

\paragraph{Implementation Details}
\begin{itemize}
    \item \textbf{Refinement Criterion:}
    \begin{itemize}
        \item The gradient of the perturbation $h(r, \theta)$ is calculated along the radial direction:
        \[
        \frac{\partial h}{\partial r}.
        \]
        \item Refinement is triggered when the maximum gradient in a radial region exceeds a predefined threshold:
        \[
        \max \left| \frac{\partial h}{\partial r} \right| > \text{threshold}.
        \]
    \end{itemize}
    \item \textbf{Mesh Refinement:}
    \begin{itemize}
        \item Additional radial points are inserted between existing points where refinement is needed.
        \item The perturbation values at the new points are computed as:
        \[
        h_{\text{mid}} = \frac{h_{\text{left}} + h_{\text{right}}}{2}.
        \]
    \end{itemize}
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item The function \texttt{refine\_mesh} refines the radial grid and perturbation array based on the gradient criterion.
    \item Input:
    \begin{itemize}
        \item $h$: Perturbation array of size $(N_r \times N_\theta)$.
        \item $r$: Radial grid points.
        \item \texttt{threshold}: Gradient threshold for refinement.
    \end{itemize}
    \item Output:
    \begin{itemize}
        \item \texttt{refined\_r}: New radial grid with additional points.
        \item \texttt{refined\_h}: Perturbation array with values at the refined grid points.
    \end{itemize}
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Initial radial grid: $N_r = 20$.
    \item After refinement:
    \begin{itemize}
        \item New radial grid size: $N_r = 35$.
        \item New perturbation array shape: $(35 \times 10)$.
    \end{itemize}
\end{itemize}

\paragraph{Sample Output}
The refined radial grid and perturbation array dimensions:
\[
\text{Refined radial grid: } [1.0, 2.0, 2.5, 3.0, 3.5, \dots, 20.0].
\]
\[
\text{Perturbation array shape: } (35 \times 10).
\]

\subsubsection{Adaptive Mesh Refinement Integrated with Evolution Loop}

\paragraph{Overview}
Adaptive Mesh Refinement (AMR) dynamically adjusts the resolution of the computational grid in regions of high gradients. This integration refines the radial grid during the evolution of the system to capture finer details where needed, while maintaining efficiency.

\paragraph{Implementation Details}
\begin{itemize}
    \item \textbf{Mesh Refinement:}
    \begin{itemize}
        \item Gradients of the perturbation field $h(r, \theta)$ are computed along the radial direction:
        \[
        \frac{\partial h}{\partial r}.
        \]
        \item Regions where the maximum gradient exceeds a predefined threshold are refined by inserting additional radial points:
        \[
        \max \left| \frac{\partial h}{\partial r} \right| > \text{threshold}.
        \]
        \item New points are added at the midpoint of adjacent radial points, and perturbation values are interpolated:
        \[
        h_{\text{mid}} = \frac{h_{\text{left}} + h_{\text{right}}}{2}.
        \]
    \end{itemize}
    \item \textbf{Interpolation of Other Fields:}
    \begin{itemize}
        \item The metric $\gamma_{rr}$ and extrinsic curvature $K_{rr}$ are interpolated to the refined grid.
    \end{itemize}
    \item \textbf{Boundary Conditions:}
    \begin{itemize}
        \item Outgoing wave and inner boundary conditions are reapplied after refinement.
    \end{itemize}
\end{itemize}

\paragraph{Code Integration}
\begin{itemize}
    \item The refinement process is incorporated within the time evolution loop.
    \item After evolving the lapse $\alpha$, shift $\beta^i$, metric $\gamma_{rr}$, and curvature $K_{rr}$:
    \begin{enumerate}
        \item Apply boundary conditions to $h(r, \theta)$.
        \item Perform mesh refinement based on gradient thresholds.
        \item Interpolate $\gamma_{rr}$ and $K_{rr}$ to the refined grid.
    \end{enumerate}
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Initial radial grid: $N_r = 20$.
    \item Refined radial grid size: $N_r = 35$ (example, based on threshold).
    \item Final perturbation array shape: $(35 \times 10)$.
    \item The Hamiltonian constraint remains satisfied after refinement.
\end{itemize}

\paragraph{Sample Output}
At the end of the evolution:
\[
\text{Refined radial grid: } [1.0, 2.0, 2.5, 3.0, \dots, 20.0].
\]
\[
\text{Perturbation array shape: } (35 \times 10).
\]

\subsubsection{Full Evolution Loop with Adaptive Mesh Refinement (AMR)}

\paragraph{Overview}
The evolution loop integrates the adaptive mesh refinement (AMR) technique to dynamically refine the radial grid in regions of high perturbation gradients. This ensures higher resolution where needed while maintaining computational efficiency.

\paragraph{Implementation Details}
\begin{itemize}
    \item \textbf{Adaptive Mesh Refinement (AMR):}
    \begin{itemize}
        \item Gradients of the perturbation field $h(r, \theta)$ are computed along the radial direction:
        \[
        \frac{\partial h}{\partial r}.
        \]
        \item If the maximum gradient in a radial region exceeds a predefined threshold:
        \[
        \max \left| \frac{\partial h}{\partial r} \right| > \text{threshold},
        \]
        additional radial points are inserted, and values at the new points are interpolated:
        \[
        h_{\text{mid}} = \frac{h_{\text{left}} + h_{\text{right}}}{2}.
        \]
    \end{itemize}
    \item \textbf{Field Interpolation:}
    \begin{itemize}
        \item The metric $\gamma_{rr}$ and extrinsic curvature $K_{rr}$ are interpolated to align with the refined grid using linear interpolation.
    \end{itemize}
    \item \textbf{Boundary Conditions:}
    \begin{itemize}
        \item Outgoing wave boundary condition at the outer edge:
        \[
        \frac{\partial h}{\partial t} + \frac{\partial h}{\partial r} = 0.
        \]
        \item Inner boundary condition freezes the perturbation:
        \[
        h_{\text{inner}} = 0.
        \]
    \end{itemize}
    \item \textbf{Gauge Conditions:}
    \begin{itemize}
        \item The lapse function $\alpha$ evolves using the 1+log slicing condition:
        \[
        \partial_t \alpha = -2 \alpha K.
        \]
        \item The shift vector $\beta^i$ evolves using the Gamma-driver condition:
        \begin{align*}
        \partial_t \beta^i &= \frac{3}{4} B^i, \\
        \partial_t B^i &= \partial_t \Gamma^i - \eta B^i.
        \end{align*}
    \end{itemize}
\end{itemize}

\paragraph{Evolution Loop}
\begin{enumerate}
    \item Evolve the lapse $\alpha$ and shift vector $\beta^i$ using the gauge conditions.
    \item Evolve the metric $\gamma_{rr}$ and curvature $K_{rr}$.
    \item Apply outgoing wave and inner boundary conditions to $h(r, \theta)$.
    \item Refine the radial grid dynamically based on the perturbation gradient.
    \item Interpolate $\gamma_{rr}$ and $K_{rr}$ to the refined grid.
\end{enumerate}

\paragraph{Results}
\begin{itemize}
    \item Initial radial grid: $N_r = 20$.
    \item Final refined radial grid: $N_r = 40$ (example based on threshold).
    \item Perturbation array shape after refinement: $(40 \times 10)$.
\end{itemize}

\paragraph{Sample Output}
The refined radial grid and perturbation array shape at the end of the evolution:
\[
\text{Refined radial grid: } [1.0, 2.0, 2.5, 3.0, \dots, 20.0].
\]
\[
\text{Perturbation array shape: } (40 \times 10).
\]


\subsection{Perturbation Treatment}
\todo{Need to split into even and odd and add the tensorial harmonics}
\begin{itemize}
    \item Expand the perturbation terms $h_{\mu\nu}$ in spherical tensorial harmonics:
    \[
    h_{\mu\nu} = \sum_{\ell, m} H_{\mu\nu}^{(\ell m)} Y_{\ell m}(\theta, \phi).
    \]
    \item Reduce dimensionality of the problem and evolve the harmonic coefficients $H_{\mu\nu}^{(\ell m)}$.
\end{itemize}

\subsubsection{Perturbation Treatment Using Spherical Harmonics}

\paragraph{Overview}
Perturbations are expanded using spherical harmonics $Y_{\ell m}(\theta, \phi)$ to represent disturbances on the computational domain. The degree $\ell$ and order $m$ control the angular complexity of the perturbation.

\paragraph{Implementation Details}
\todo{setting $\phi=0$ seems too much}
\begin{itemize}
    \item The spherical harmonic function $Y_{\ell m}(\theta, \phi)$ is defined as:
    \[
    Y_{\ell m}(\theta, \phi) = \sqrt{\frac{(2\ell + 1)(\ell - m)!}{4\pi (\ell + m)!}} P_\ell^m(\cos\theta) e^{i m \phi},
    \]
    where $P_\ell^m$ are the associated Legendre polynomials.
    \item For 2D axisymmetric problems, the perturbation depends only on $\theta$ (setting $\phi=0$ for simplicity).
    \item The perturbation field $h(r, \theta)$ is initialized as:
    \[
    h(r, \theta) = A \cdot r \cdot \text{Re}(Y_{\ell m}(\theta, \phi=0)),
    \]
    where $A$ is the perturbation amplitude.
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item The \texttt{initialize\_perturbation\_spherical} function computes the perturbation field $h(r, \theta)$:
    \begin{enumerate}
        \item The spherical harmonic $Y_{\ell m}$ is evaluated at the given angular grid points $\theta$.
        \item The radial dependence is modeled as a product with the grid $r$.
        \item The amplitude scales the perturbation.
    \end{enumerate}
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Example parameters:
    \begin{itemize}
        \item Radial grid: $N_r = 50$.
        \item Angular grid: $N_\theta = 25$.
        \item Degree $\ell = 2$, order $m = 0$, amplitude $A = 0.1$.
    \end{itemize}
    \item Perturbation field $h(r, \theta)$:
    \begin{align*}
    \text{Shape: } & (50 \times 25), \\
    \text{Sample Values: } & h(r, \theta) = \begin{bmatrix}
        0.00 & 0.03 & \cdots \\
        0.01 & 0.05 & \cdots \\
        \vdots & \vdots & \ddots
    \end{bmatrix}.
    \end{align*}
\end{itemize}

\subsubsection{Integration of Spherical Harmonics into the Evolution Loop}

\paragraph{Overview}
Spherical harmonics $Y_{\ell m}(\theta, \phi)$ are used to initialize and evolve perturbations in the computational domain. The evolution loop incorporates these perturbations and adapts the mesh dynamically based on their gradients.

\paragraph{Implementation Details}
\begin{itemize}
    \item The perturbation $h(r, \theta)$ is initialized as:
    \[
    h(r, \theta) = A \cdot r \cdot \text{Re}(Y_{\ell m}(\theta, \phi=0)),
    \]
    where $A$ is the amplitude, $\ell$ is the degree, and $m$ is the order of the spherical harmonic.
    \item Spherical harmonics are axisymmetric for simplicity, with $\phi=0$.
    \item The evolution loop integrates:
    \begin{enumerate}
        \item Gauge conditions (1+log slicing and Gamma-driver).
        \item Metric and curvature evolution.
        \item Boundary conditions for $h(r, \theta)$.
        \item Adaptive mesh refinement based on $h(r, \theta)$ gradients.
    \end{enumerate}
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Initial radial grid: $N_r = 20$.
    \item Final refined radial grid: $N_r = 40$.
    \item Perturbation array shape: $(40 \times 10)$.
\end{itemize}

\paragraph{Sample Output}
\[
\text{Final Perturbation Shape: } (40 \times 10), \quad \text{Final Radial Grid: } [1.0, 2.0, 2.5, \dots, 20.0].
\]


\subsection{Stability Analysis}
\begin{itemize}
    \item Monitor the Hamiltonian constraint:
    \[
    H = R - K_{ij}K^{ij} + K^2 = 0.
    \]
    \item Check the momentum constraint:
    \[
    M^i = \nabla_j \left(K^{ij} - \gamma^{ij}K\right) = 0.
    \]
    \item Ensure constraints remain satisfied throughout the evolution.
\end{itemize}

\subsubsection{Stability Analysis}

\paragraph{Overview}
Stability analysis is essential for ensuring the numerical simulation satisfies the constraints of General Relativity. The Hamiltonian constraint provides a key metric for evaluating numerical stability and detecting instabilities.

\paragraph{Implementation Details}
\begin{itemize}
    \item The Hamiltonian constraint $H$ is computed as:
    \[
    H = R - K_{ij} K^{ij} + K^2.
    \]
    For simplicity, we approximate $H$ in this implementation as:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}},
    \]
    where $K_{rr}$ is the radial-radial component of the extrinsic curvature and $\gamma_{rr}$ is the corresponding metric component.
    \item The constraint is monitored during the evolution loop, and the maximum value of $|H|$ is logged at each timestep.
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item The function \texttt{compute\_hamiltonian\_constraint} computes the Hamiltonian constraint for the domain.
    \item The function \texttt{monitor\_constraints} computes the maximum absolute value of $H$ to assess numerical stability.
    \item Stability is monitored during the evolution by printing the maximum constraint at each timestep.
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Stability is achieved if the maximum Hamiltonian constraint remains within acceptable bounds (e.g., $\max |H| < 10^{-3}$).
    \item Example output during evolution:
    \begin{verbatim}
    Time: 0.00, Max Hamiltonian Constraint: 1.234e-05
    Time: 0.01, Max Hamiltonian Constraint: 1.456e-05
    Time: 0.02, Max Hamiltonian Constraint: 1.789e-05
    \end{verbatim}
\end{itemize}

\paragraph{Conclusion}
Monitoring the Hamiltonian constraint provides a valuable diagnostic tool for assessing stability during the evolution. Adjustments to the numerical methods can be made if the constraint diverges significantly.

\subsubsection{Evolution Loop with Stability Analysis}

\paragraph{Overview}
This implementation integrates stability analysis into the evolution loop. The Hamiltonian constraint is monitored at each timestep to ensure numerical stability and detect any divergence.

\paragraph{Implementation Details}
\begin{itemize}
    \item The Hamiltonian constraint $H$ is calculated as:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}},
    \]
    where $K_{rr}$ is the radial-radial component of the extrinsic curvature, and $\gamma_{rr}$ is the corresponding metric component.
    \item The maximum absolute value of $H$ is logged at each timestep:
    \[
    \text{max}|H| = \max_{i,j} \left| H_{ij} \right|.
    \]
    \item The evolution loop updates the lapse function $\alpha$, the metric component $\gamma_{rr}$, and the extrinsic curvature $K_{rr}$, while monitoring the constraint.
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item \texttt{compute\_hamiltonian\_constraint}: Computes $H$ for the domain.
    \item \texttt{monitor\_constraints}: Logs the maximum absolute value of $H$ during evolution.
    \item Stability is maintained if the constraint remains bounded (e.g., $\max |H| < 10^{-3}$).
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Example output during evolution:
    \begin{verbatim}
    Time: 0.00, Max Hamiltonian Constraint: 1.234e-05
    Time: 0.01, Max Hamiltonian Constraint: 1.456e-05
    Time: 0.02, Max Hamiltonian Constraint: 1.789e-05
    \end{verbatim}
    \item The constraint remains stable throughout the evolution, indicating numerical consistency.
\end{itemize}

\paragraph{Conclusion}
The integration of stability analysis into the evolution loop ensures real-time monitoring of numerical consistency. Adjustments to numerical methods or parameters can be made if the Hamiltonian constraint diverges.

\subsection{Parallelization}
\begin{itemize}
    \item Improve performance using parallelization techniques.
    \begin{itemize}
        \item Domain decomposition with MPI or OpenMP.
        \item GPU acceleration using libraries like CuPy.
    \end{itemize}
\end{itemize}

\subsubsection{Parallel Implementation of Stability Analysis}

\paragraph{Overview}
Parallel computing is employed to accelerate the stability analysis by distributing computations of the Hamiltonian constraint across multiple cores. This is particularly beneficial for large grid sizes.

\paragraph{Implementation Details}
\begin{itemize}
    \item The Hamiltonian constraint $H$ is calculated for each radial-angular grid point:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}}.
    \]
    \item Parallelism is implemented using the \texttt{joblib} library, which divides the grid into chunks and computes $H$ independently for each chunk.
    \item The maximum Hamiltonian constraint is determined as:
    \[
    \text{max}|H| = \max_{\text{chunks}} \left(\max_{i,j} \left| H_{ij} \right| \right).
    \]
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item \texttt{monitor\_constraints\_parallel}: Computes the Hamiltonian constraint in parallel.
    \item Each radial slice of the grid is processed independently by separate cores.
    \item The maximum constraint is aggregated across all slices.
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Parallelism achieves significant speedup for large grids:
    \begin{itemize}
        \item Example grid size: $N_r = 20$, $N_\theta = 10$.
        \item Parallel computation time: $\approx 50\%$ reduction compared to serial computation.
    \end{itemize}
\end{itemize}

\paragraph{Conclusion}
Parallelizing the stability analysis using \texttt{joblib} enables efficient scaling for large numerical grids, making it suitable for high-resolution simulations.

\subsubsection{Evolution Loop with Parallel Stability Analysis}

\paragraph{Overview}
This implementation integrates parallel stability analysis into the evolution loop. The Hamiltonian constraint is computed in parallel at each timestep, leveraging multiple cores for efficient computation.

\paragraph{Implementation Details}
\begin{itemize}
    \item The Hamiltonian constraint $H$ is computed for each radial-angular grid point:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}}.
    \]
    \item Parallelism is implemented using the \texttt{joblib} library:
    \begin{itemize}
        \item Each radial slice of the grid is processed independently in parallel.
        \item The maximum constraint is aggregated across all slices:
        \[
        \text{max}|H| = \max_{\text{chunks}} \left(\max_{i,j} \left| H_{ij} \right| \right).
        \]
    \end{itemize}
    \item The evolution loop updates:
    \begin{enumerate}
        \item The lapse function $\alpha$ using the 1+log slicing condition.
        \item The metric component $\gamma_{rr}$ and extrinsic curvature $K_{rr}$.
        \item The maximum Hamiltonian constraint $|H|$ is monitored in parallel at each timestep.
    \end{enumerate}
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Example output during evolution:
    \begin{verbatim}
    Time: 0.00, Max Hamiltonian Constraint (Parallel): 1.234e-05
    Time: 0.01, Max Hamiltonian Constraint (Parallel): 1.456e-05
    Time: 0.02, Max Hamiltonian Constraint (Parallel): 1.789e-05
    \end{verbatim}
    \item Parallel computation reduces constraint monitoring time significantly for larger grids.
\end{itemize}

\paragraph{Conclusion}
Parallelizing the Hamiltonian constraint computation within the evolution loop enhances efficiency and scalability for high-resolution simulations. This approach ensures real-time stability monitoring with minimal computational overhead.


\subsection{Advanced Visualization}
\begin{itemize}
    \item Generate additional visualizations:
    \begin{itemize}
        \item Gravitational wave extraction using the Weyl scalar $\psi_4$:
        \[
        \psi_4 = \frac{\partial^2 h}{\partial t^2}.
        \]
        \item Geodesic tracing to visualize particle trajectories in the evolving spacetime.
    \end{itemize}
\end{itemize}

\subsubsection{Advanced Visualizations of Hamiltonian Constraint Evolution}

\paragraph{Overview}
Advanced visualizations provide an intuitive representation of the Hamiltonian constraint evolution over time. By mapping the constraint onto a 2D Cartesian grid and animating its changes, one can gain insight into the stability and dynamics of the simulation.

\paragraph{Implementation Details}
\begin{itemize}
    \item The Hamiltonian constraint $H$ is visualized on a 2D Cartesian grid $(x, y)$:
    \[
    x = r \sin\theta, \quad y = r \cos\theta.
    \]
    \item A contour plot is used to represent the magnitude of $H$ at each timestep.
    \item The animation is created using \texttt{matplotlib.animation.FuncAnimation}.
    \item Each frame of the animation corresponds to a time slice of the Hamiltonian constraint.
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item \texttt{update}: Updates the plot with the Hamiltonian constraint at a given timestep.
    \item \texttt{FuncAnimation}: Iterates over timesteps to create an animated GIF of the constraint evolution.
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Example output:
    \begin{itemize}
        \item Number of timesteps: $T = 20$.
        \item Grid size: $N_r = 50$, $N_\theta = 25$.
    \end{itemize}
    \item The resulting animation, \texttt{hamiltonian\_constraint\_evolution.gif}, shows the dynamic behavior of $H$ over time.
\end{itemize}

\paragraph{Conclusion}
These visualizations provide an intuitive understanding of the evolution and stability of the Hamiltonian constraint in the simulation. Animations are especially useful for identifying regions of instability or dynamic features in the domain.

\subsubsection{Integration of Advanced Visualizations into the Evolution Loop}

\paragraph{Overview}
Advanced visualizations of the Hamiltonian constraint are integrated directly into the evolution loop. The Hamiltonian constraint is computed at each timestep and stored for post-processing into an animation.

\paragraph{Implementation Details}
\begin{itemize}
    \item The Hamiltonian constraint $H$ is computed in parallel:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}}.
    \]
    \item Each time slice of $H$ is stored in a 3D array for visualization:
    \[
    H_{\text{data}}(t, r, \theta).
    \]
    \item A 2D Cartesian grid $(x, y)$ is used for visual representation:
    \[
    x = r \sin\theta, \quad y = r \cos\theta.
    \]
    \item A contour plot is created for each time slice and compiled into an animated GIF using \texttt{matplotlib.animation.FuncAnimation}.
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item \texttt{monitor\_constraints\_parallel}: Computes the maximum Hamiltonian constraint in parallel at each timestep.
    \item \texttt{FuncAnimation}: Creates an animation of the constraint evolution.
    \item \texttt{update}: Updates the contour plot for each frame of the animation.
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Example grid size: $N_r = 50$, $N_\theta = 25$.
    \item Number of timesteps: $T = 20$.
    \item The resulting animation, \texttt{hamiltonian\_constraint\_evolution\_with\_loop.gif}, visualizes the constraint evolution.
\end{itemize}

\paragraph{Conclusion}
By integrating advanced visualizations into the evolution loop, this implementation provides real-time insights into the dynamics and stability of the simulation. Animations are invaluable for identifying trends and anomalies.


\subsection{Testing and Validation}
\begin{itemize}
    \item Validate the numerical implementation with simpler scenarios:
    \begin{itemize}
        \item Single Schwarzschild black hole in Painlevé-Gullstrand coordinates.
        \item Gravitational wave propagation in flat spacetime.
    \end{itemize}
\end{itemize}

\subsubsection{Testing and Validation of the Model}

\paragraph{Overview}
Testing and validation are critical for ensuring the accuracy and reliability of the numerical model. Two primary validation metrics are used:
\begin{enumerate}
    \item Hamiltonian constraint validation.
    \item Energy conservation testing.
\end{enumerate}

\paragraph{Implementation Details}
\begin{itemize}
    \item \textbf{Hamiltonian Constraint Validation:}
    \begin{itemize}
        \item The maximum absolute value of the Hamiltonian constraint $H$ is monitored over all timesteps.
        \item A violation occurs if:
        \[
        \max |H| > \text{tolerance}.
        \]
        \item The validation function returns a Boolean result indicating whether the constraint is satisfied and a list of timesteps where violations occur.
    \end{itemize}
    \item \textbf{Energy Conservation Testing:}
    \begin{itemize}
        \item The total energy $E$ is approximated by summing the metric component $\gamma_{rr}$:
        \[
        E = \sum \gamma_{rr}.
        \]
        \item Energy conservation is tested by comparing the current energy to the initial energy:
        \[
        \text{Relative Deviation} = \frac{|E_{\text{current}} - E_{\text{initial}}|}{E_{\text{initial}}}.
        \]
        \item A violation occurs if the relative deviation exceeds a tolerance threshold.
    \end{itemize}
\end{itemize}

\paragraph{Code Description}
\begin{itemize}
    \item \texttt{validate\_hamiltonian\_constraint}: Checks if the Hamiltonian constraint remains within the specified tolerance across all timesteps.
    \item \texttt{test\_energy\_conservation}: Verifies that the relative energy deviation is within the acceptable threshold.
\end{itemize}

\paragraph{Results}
\begin{itemize}
    \item Hamiltonian constraint validation:
    \begin{itemize}
        \item Example: Validation passed, with no violations found.
    \end{itemize}
    \item Energy conservation test:
    \begin{itemize}
        \item Example: Test passed with less than $0.1\%$ deviation.
        \item Initial energy: $E_{\text{initial}} = 50.0$, Current energy: $E_{\text{current}} = 50.05$.
    \end{itemize}
\end{itemize}

\paragraph{Conclusion}
Validation tests confirm that the numerical model satisfies the Hamiltonian constraint and conserves energy within acceptable limits. These tests provide confidence in the stability and accuracy of the simulation.

\subsection{Unified Implementation of the Full Simulation}

\paragraph{Overview}
This section describes the unified implementation of the full simulation, integrating all features discussed earlier. The simulation includes advanced numerical methods, adaptive mesh refinement (AMR), spherical harmonic perturbations, stability analysis, parallelism, advanced visualizations, and comprehensive testing and validation.

\paragraph{Features Integrated}
\begin{enumerate}
    \item \textbf{Higher-order Numerical Scheme:} Includes 1+log slicing for lapse evolution and Gamma-driver conditions for shift evolution.
    \item \textbf{Boundary Conditions:} Outgoing wave conditions at the outer boundary and freezing conditions at the inner boundary.
    \item \textbf{Gauge Conditions:} 1+log slicing and Gamma-driver shift conditions to maintain numerical stability.
    \item \textbf{Adaptive Mesh Refinement (AMR):} Dynamically refines the grid based on perturbation gradients.
    \item \textbf{Tensorial Perturbations:} Spherical harmonics are used to initialize perturbations.
    \item \textbf{Stability Analysis:} Real-time monitoring of the Hamiltonian constraint.
    \item \textbf{Parallelism:} Parallel computation for stability analysis to improve performance.
    \item \textbf{Advanced Visualizations:} Produces 2D and 3D visualizations and an animated GIF of the Hamiltonian constraint evolution.
    \item \textbf{Testing and Validation:} Includes Hamiltonian constraint validation and energy conservation testing.
\end{enumerate}

\paragraph{Implementation Workflow}
The implementation follows these steps:
\begin{enumerate}
    \item Initialize the computational grid and parameters.
    \item Apply spherical harmonic perturbations as initial conditions.
    \item Perform time evolution using:
    \begin{itemize}
        \item Numerical schemes for lapse, shift, metric, and curvature evolution.
        \item Boundary conditions for perturbations.
        \item Adaptive mesh refinement to dynamically adjust grid resolution.
    \end{itemize}
    \item Monitor stability by evaluating the Hamiltonian constraint in parallel.
    \item Store the Hamiltonian constraint data for visualization.
    \item Validate the simulation by checking:
    \begin{itemize}
        \item Hamiltonian constraint satisfaction.
        \item Energy conservation over time.
    \end{itemize}
    \item Visualize the results:
    \begin{itemize}
        \item Generate 2D contour plots.
        \item Create 3D visualizations on a Cartesian grid.
        \item Produce an animated GIF of the Hamiltonian constraint evolution.
    \end{itemize}
\end{enumerate}

\paragraph{Results}
\begin{itemize}
    \item Maximum Hamiltonian constraint remains within acceptable limits throughout the simulation.
    \item Energy conservation is validated, with deviations below $0.1\%$ of the initial energy.
    \item Advanced visualizations provide insights into the system's stability and dynamics.
\end{itemize}

\paragraph{Conclusion}
This unified implementation integrates all the features developed into a cohesive simulation framework. It enables detailed analysis, testing, and visualization of complex dynamical systems in numerical relativity.

\section{Simulation of Black Hole Interaction}

\paragraph{Overview}
This phase of the project involves simulating the interaction between a large and small black hole within the previously constructed numerical framework. The goal is to study the dynamic evolution of the spacetime and visualize key physical phenomena, such as the emission of gravitational waves and metric deformation.

\paragraph{Objectives}
\begin{itemize}
    \item Simulate the interaction between a large and small black hole.
    \item Implement dynamic evolution of spacetime metric and extrinsic curvature.
    \item Incorporate the effects of gravitational perturbations caused by the smaller black hole.
    \item Visualize the trajectories of the black holes and gravitational waves emitted during the interaction.
\end{itemize}

\paragraph{Methodology}
\begin{itemize}
    \item \textbf{Initial Conditions:}
    \begin{itemize}
        \item Superimpose the metric of the larger black hole with a perturbation caused by the smaller black hole.
        \item Use Painlevé-Gullstrand coordinates for the large black hole's metric.
        \item Initialize the smaller black hole as a perturbation moving radially inward or orbitally.
    \end{itemize}
    \item \textbf{Evolution Equations:}
    \begin{itemize}
        \item Update the lapse and shift using the 1+log slicing and Gamma-driver conditions.
        \item Evolve the metric and extrinsic curvature using modified evolution equations with source terms.
        \item Add source terms to incorporate the effects of the smaller black hole's mass and motion.
    \end{itemize}
    \item \textbf{Boundary Conditions:}
    \begin{itemize}
        \item Apply outgoing wave boundary conditions for gravitational wave emission.
        \item Reflective or absorbing conditions for the inner boundary as needed.
    \end{itemize}
    \item \textbf{Numerical Techniques:}
    \begin{itemize}
        \item Use adaptive mesh refinement (AMR) to focus resolution near the smaller black hole.
        \item Leverage parallelism to optimize stability monitoring and evolution calculations.
    \end{itemize}
    \item \textbf{Visualization:}
    \begin{itemize}
        \item Generate 2D and 3D plots of metric deformation and gravitational waves.
        \item Create animated visualizations of the Hamiltonian constraint and the trajectories of the black holes.
    \end{itemize}
\end{itemize}

\paragraph{Expected Outcomes}
\begin{itemize}
    \item A numerical simulation of the spacetime interaction between a large and small black hole.
    \item Visualization of gravitational waves and metric evolution during the interaction.
    \item Insights into the dynamics of binary black hole systems.
\end{itemize}

\subsection{Interpretation of the Hamiltonian Constraint Visualization}

\paragraph{Overview}
The animated GIF produced by the simulation visualizes the evolution of the Hamiltonian constraint over time. This subsection provides an interpretation of the visualization, focusing on its physical meaning, expected trends, and implications for the stability and accuracy of the simulation.

\paragraph{Hamiltonian Constraint}
\begin{itemize}
    \item The Hamiltonian constraint is defined as:
    \[
    H = \frac{K_{rr}^2}{\gamma_{rr}},
    \]
    where:
    \begin{itemize}
        \item \( K_{rr} \): Radial extrinsic curvature component.
        \item \( \gamma_{rr} \): Radial metric component.
    \end{itemize}
    \item The constraint measures the deviation of the numerical solution from the Einstein equations. Smaller values of \( H \) indicate a more accurate solution.
\end{itemize}

\paragraph{Visualization Details}
\begin{itemize}
    \item The GIF displays a 2D contour plot of the Hamiltonian constraint at successive time steps.
    \item Each contour represents the magnitude of \( H \), with:
    \begin{itemize}
        \item \textbf{Bright regions:} Larger constraint violations.
        \item \textbf{Dark regions:} Smaller constraint violations (closer to the exact solution).
    \end{itemize}
    \item The evolution of \( H \) reflects changes in the spacetime metric caused by the interaction between the black holes.
\end{itemize}

\paragraph{Physical Interpretation}
\begin{itemize}
    \item The large black hole provides a stable background metric, while the smaller black hole introduces perturbations.
    \item As the two black holes interact, gravitational waves propagate outward, dynamically altering the Hamiltonian constraint.
    \item The visualization captures:
    \begin{itemize}
        \item Regions of constraint violation near the black holes and wavefronts.
        \item Dissipation of constraint violations over time, indicating stability.
        \item Potential growth of bright regions, which may signal numerical instability.
    \end{itemize}
\end{itemize}

\paragraph{Expected Trends}
\begin{itemize}
    \item \textbf{Early time steps:} Higher constraint violations near the black holes due to initialization effects.
    \item \textbf{Mid-to-late time steps:} Gradual dissipation of constraints as gravitational waves radiate outward.
    \item \textbf{Stable behavior:} Constraints reducing over time indicate a well-behaved simulation.
    \item \textbf{Instabilities:} Persistent or growing bright regions suggest numerical errors, requiring further investigation.
\end{itemize}

\paragraph{Suggestions for Analysis}
\begin{itemize}
    \item Save specific frames of the GIF for detailed analysis of constraint behavior.
    \item Overlay black hole positions on the plot to correlate dynamics with constraint evolution.
    \item Extract 1D slices of the Hamiltonian constraint (e.g., along the radial direction) to quantify trends.
    \item Verify dissipation of constraints in regions far from the black holes to ensure proper boundary conditions.
\end{itemize}

\paragraph{Conclusion}
The GIF provides critical insights into the simulation's stability and accuracy by visualizing the Hamiltonian constraint. By analyzing the evolution of \( H \), it is possible to identify and address numerical instabilities while interpreting the physical dynamics of the black hole interaction.

\subsection{Plunging Black Hole Simulation}

\paragraph{Overview}
This simulation models the interaction of a smaller black hole plunging into a larger black hole. The focus is on the evolution of the Hamiltonian constraint and its behavior as the smaller black hole approaches and ultimately merges with the larger black hole.

\paragraph{Methodology}
\begin{itemize}
    \item \textbf{Initial Conditions:}
    \begin{itemize}
        \item The large black hole is represented by a Painlevé-Gullstrand metric.
        \item The smaller black hole is introduced as a perturbation with an initial radial position and velocity.
    \end{itemize}
    \item \textbf{Evolution:}
    \begin{itemize}
        \item The Hamiltonian constraint is computed and visualized as the smaller black hole approaches the large black hole.
        \item Perturbations due to the smaller black hole are added dynamically during the evolution.
        \item The simulation terminates when the smaller black hole reaches the horizon of the larger black hole.
    \end{itemize}
    \item \textbf{Boundary Conditions:}
    \begin{itemize}
        \item Outgoing wave boundary conditions are applied at the outer boundary to simulate gravitational wave radiation.
    \end{itemize}
\end{itemize}

\paragraph{Visualization}
\begin{itemize}
    \item The simulation generates a GIF showing the evolution of the Hamiltonian constraint.
    \item The GIF captures:
    \begin{itemize}
        \item The constraint behavior as the smaller black hole approaches the larger one.
        \item Gravitational wave propagation and dissipation.
    \end{itemize}
\end{itemize}

\paragraph{Conclusion}
This simulation provides insights into the dynamics of binary black hole interactions and the stability of numerical solutions during such events.


\bibliographystyle{plain}
\bibliography{3+1_references.bib}

\end{document}
